<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>数据结构课程 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="第一章 算法分析与数据结构基础壹–算法复杂性分析: 算法复杂性: N:问题规模, I:算法输入, A:算法本身  复杂性: C &#x3D; F(N,I,A)  时间复杂性: T &#x3D; T(N,I)  &#x2F;&#x2F;时间复杂性是与问题规模和算法输入有关的函数.  空间复杂性: S &#x3D; S(N,I)    算法复杂性具体化:  抽象计算机提供的元计算 o 每一次元计算执行的时间 t 用到元计算的运算次数 e T(N,I)">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构课程">
<meta property="og:url" content="http://example.com/2020/09/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="第一章 算法分析与数据结构基础壹–算法复杂性分析: 算法复杂性: N:问题规模, I:算法输入, A:算法本身  复杂性: C &#x3D; F(N,I,A)  时间复杂性: T &#x3D; T(N,I)  &#x2F;&#x2F;时间复杂性是与问题规模和算法输入有关的函数.  空间复杂性: S &#x3D; S(N,I)    算法复杂性具体化:  抽象计算机提供的元计算 o 每一次元计算执行的时间 t 用到元计算的运算次数 e T(N,I)">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:/Users/王冠骅/AppData/Roaming/Typora/typora-user-images/image-20201224091944620.png">
<meta property="og:image" content="c:/Users/王冠骅/AppData/Roaming/Typora/typora-user-images/image-20201019200347142.png">
<meta property="og:image" content="c:/Users/王冠骅/AppData/Roaming/Typora/typora-user-images/image-20201224154815139.png">
<meta property="og:image" content="c:/Users/王冠骅/AppData/Roaming/Typora/typora-user-images/image-20201224211119329.png">
<meta property="og:image" content="https://pic2.zhimg.com/v2-ecade466b0473b55dd6bea9a73df68e1_r.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/v2-75b99216e5bba6c6a0c1100525a9d0e7_r.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-b380d3e99b7b3ee4508e129e66266aab_1440w.jpg">
<meta property="og:image" content="c:/Users/王冠骅/AppData/Roaming/Typora/typora-user-images/image-20201224214329624.png">
<meta property="og:image" content="c:/Users/王冠骅/AppData/Roaming/Typora/typora-user-images/image-20201204201220896.png">
<meta property="og:image" content="c:/Users/王冠骅/AppData/Roaming/Typora/typora-user-images/image-20201214093207793.png">
<meta property="og:image" content="c:/Users/王冠骅/AppData/Roaming/Typora/typora-user-images/image-20201214093914092.png">
<meta property="og:image" content="c:/Users/王冠骅/AppData/Roaming/Typora/typora-user-images/image-20201218154010424.png">
<meta property="article:published_time" content="2020-09-07T02:21:41.000Z">
<meta property="article:modified_time" content="2021-01-04T16:08:09.849Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/王冠骅/AppData/Roaming/Typora/typora-user-images/image-20201224091944620.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-数据结构课程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/09/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2020-09-07T02:21:41.000Z" itemprop="datePublished">2020-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      数据结构课程
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="第一章-算法分析与数据结构基础"><a href="#第一章-算法分析与数据结构基础" class="headerlink" title="第一章 算法分析与数据结构基础"></a>第一章 算法分析与数据结构基础</h1><h2 id="壹–算法复杂性分析"><a href="#壹–算法复杂性分析" class="headerlink" title="壹–算法复杂性分析:"></a>壹–算法复杂性分析:</h2><ol>
<li><p>算法复杂性: N:问题规模, I:算法输入, A:算法本身<br>  复杂性: C = F(N,I,A)<br>  时间复杂性: T = T(N,I)  //时间复杂性是与问题规模和算法输入有关的函数.<br>  空间复杂性: S = S(N,I)  </p>
</li>
<li><p>算法复杂性具体化:</p>
<ul>
<li>抽象计算机提供的元计算 o</li>
<li>每一次元计算执行的时间 t</li>
<li>用到元计算的运算次数 e</li>
<li>T(N,I) = Σte(N,I)  //单个时间的运算次数与元计算时间之积</li>
<li>计算步: 算法中语句的执行次数. 算法花费的时间与算法中语句的执行次数乘正比例.</li>
<li>算法的基本操作重复执行的次数是模块n中的某一个函数f(n), T(n) = O ( f(n) )  //与n的一个函数</li>
</ul>
</li>
<li><p>规定输入</p>
<ul>
<li>I* Tmax(最坏情况下)</li>
<li>I~ Tmin(最好情况下)</li>
</ul>
</li>
<li><p>渐进表达</p>
<ol>
<li>复杂性渐进型态: 当N单增趋于∞时,T(N)也单增于∞<br>若存在T<del>(N)当N-&gt;∞时(T(N) - T</del>(N))/T(N) -&gt; 0<br>T<del>(N)位T(N)渐进性态.<br>直观上T</del>(N)时T(N)中略去低阶项留下的主项</li>
</ol>
</li>
<li><p>渐进分析的符号   Q: c是小数和整数意义不一样</p>
<ol>
<li>O() 渐进上界符号: O(g(n)) = { f(n) | 存在正常数c和n0使得对所有n&gt;=n0, 有: 0 &lt;= f(n) &lt;= cg(n)}<br>即 f(n)的时间复杂度小于g(n)的时间复杂度</li>
<li>Ω() 渐进下界符号{0 &lt;= cg(n) &lt;= f(n)}<br>f()的时间复杂度小于g(n)</li>
<li>θ() 紧渐进界: c1g(n) &lt;= f(n) &lt;= c2g(n)</li>
<li>o() 非紧上界记号, 无等号</li>
<li>记忆关系<ul>
<li>f(n) = O(g(n)) -&gt; a &lt;= b</li>
<li>f(n) = Ω(g(n)) -&gt; a &lt;= b</li>
</ul>
</li>
</ol>
</li>
<li><p>渐进计算中的规则</p>
<pre><code>1. O(f(n)) + O(g(n)) = O(max&#123;f(n),g(n)&#125;)     //忽略常倍数
2. O(f(n)) + O(g(n)) = O(f(n) + g(n))
3. O(f(n)) * O(g(n)) = O(f(n) * g(n))</code></pre>
</li>
</ol>
<h2 id="贰-数据结构"><a href="#贰-数据结构" class="headerlink" title="贰 数据结构"></a>贰 数据结构</h2><ol>
<li>数据结构四元组: (D, L, S, O) 数据元素. 数据元素之间的逻辑关系. 存储结构/物理结构. 操作</li>
<li>逻辑结构: 1. 集合 2. 线性 3. 树形 4. 图形</li>
<li>存储结构: 1. 顺序存储 2. 链式存储</li>
<li>ADT抽象数据类型: D R O (R:关系)</li>
</ol>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><ol>
<li><p>基本操作:</p>
<ul>
<li>初始化与销毁: Init, Clear, Destory</li>
<li>引用型: Empty, Size, Retrival(从pos取出数据放到之阵中), Locate(定位放入指针中), Prior(前驱放入指针中), Next(后继放入指针中)</li>
<li>加工型: Insert, Delete</li>
</ul>
</li>
<li><p>数组描述: </p>
<pre><code>1. 选择映射方法
    * loc(i) = i;
    * loc(i) = arrLen - i - 1;    从尾部储存
    * loc(i) = (loc(0) + i) % arrLen;    //从loc(0)开始将元素循环排序</code></pre>
</li>
<li><p>单链表的变形</p>
<ol>
<li>循环单链表: 与单链表的区别仅在于判断最后的节点是后记是否为头节点</li>
</ol>
</li>
</ol>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ol>
<li>顺序存储<ol>
<li>出栈, 入栈</li>
<li>多个顺序栈空间共享: 前入栈(前栈+1, 后栈+1)</li>
</ol>
</li>
<li>链式存储<ol>
<li>单链表首端作为栈顶</li>
</ol>
</li>
</ol>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ol>
<li><p>定义: 只能在表的一端进行插入, 一端删除 FIFO(先进先出) 队头front 队尾rear</p>
</li>
<li><p>基本操作: 初始化, 销毁, 清空, 判空, 判满, 入队, 出队</p>
</li>
<li><p>数组描述:</p>
<ol>
<li><p>location(i) = ( location(队首元素) + i ) % arrayLength         //环形数组描述</p>
</li>
<li><p>queueFront: 指向队列首元素的前一个位置, queueRear: 指向末尾元素</p>
<img src="C:\Users\王冠骅\AppData\Roaming\Typora\typora-user-images\image-20201224091944620.png" alt="image-20201224091944620" style="zoom: 67%;" />



</li>
</ol>
</li>
</ol>
<h2 id="叁-查找算法"><a href="#叁-查找算法" class="headerlink" title="叁 查找算法"></a>叁 查找算法</h2><ol>
<li><p>KMP字符串匹配算法</p>
<ol>
<li>准备: pat模式串M    txt文本串N    dp数组    在txt中查找pat,如果存在,返回子串的起始索引, 否则-1</li>
<li>与暴力算法的区别: 花费空间以记录字符串信息防止过多循环, 用空间换时间</li>
<li>永不回退txt的指针i, 不会重复扫描txt, 借助dp数组中的信息把pat移到正确的位置继续匹配</li>
<li>dp数组只和pat有关</li>
<li>pat的匹配时状态的转移, 转移到哪个状态由待匹配字符串决定</li>
<li>KMP核心: 构造状态转移图 当前匹配状态, 遇到的字符</li>
</ol>
</li>
<li><p>概念们</p>
<ol>
<li>主次关键字</li>
<li>平均查找长度ASL = ∑P₁C₁    P: 查找第i个元素的效率 C: 查找第i个元素的比较次数</li>
</ol>
</li>
<li><p>顺序查找</p>
<ol>
<li>设置岗哨, 从后向前查找, 返回信息在表中的位置</li>
</ol>
</li>
<li><p>折半查找(二分查找)</p>
<ol>
<li> 性能分析: ASL ≈ Log₂(n+1) - 1; 不超过折半查找树的树高</li>
</ol>
</li>
<li><p>索引表查找</p>
<ol>
<li>构建:<ol>
<li>分块</li>
<li>建立索引项: 关键字项(块中最大关键字), 指针项(第一个记录在表中的位置) </li>
</ol>
</li>
</ol>
</li>
<li><p>哈希查找</p>
<ol>
<li>核心思想: 在关键字与记录在表中的储存位置之间建立一个函数关系, 以H(key)作为关键字为key的记录在表中的位置, 通常称这个函数H(key)为哈希函数</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>注意:</p>
<ol>
<li> 哈希函数是一个映像, 将关键字的集合映射到某个地址集合上</li>
<li>压缩映像: 一般容易产生冲突</li>
</ol>
</li>
<li><p>哈希表</p>
<ol>
<li>根据设定的<strong>哈希函数 **和提供的</strong>处理冲突的方法**, 将一组关键字映射到一个地址连续的储存存空间上, 并以关键字在地址空间中的向作为相应记录在表中的储存位置, 如此构造所得的查找表称之为哈希表</li>
</ol>
</li>
<li><p>哈希函数(任意关键字且冲突少, 均匀分布 )</p>
<ol>
<li>直接哈希函数: 关键字函数 或 其某个线性函数值</li>
<li>数字分析法: 使用<em>均匀</em> 分布的数字</li>
<li>平方取中法: 取关键字平方的中间位置</li>
<li>折叠法: 将关键字分割乘位数相等的几部分, 取这几部分的叠加和作为哈希地址<ul>
<li>移位叠加: 最后一位对齐</li>
<li>边界叠加: 蛇形叠加(r r-1 r-2 … 3 2 1   r+1 r+2 …. 2r-1 2r)</li>
<li>除留余数法: 取关键字呗某个不大于<strong>哈希表长度</strong>长度的数p除后作为哈希地址</li>
<li>随机数法</li>
</ul>
</li>
</ol>
</li>
<li><p>e.g: 字符串哈希查找</p>
</li>
<li><p>哈希冲突处理(由关键字得到的Hsah地址上已经有其他记录)</p>
<ol>
<li><p>开放地址法: 为产生冲突的地址求得一个地址序列</p>
<ul>
<li><p>序列查找</p>
<ul>
<li><p>线性探查: 给出一组数据(辅助散列函数), 遇到冲突后根据辅助散列函数中的值去查找</p>
</li>
<li><p>二次探查: h(k,i) = ( h’(k) + c₁i + c₂i² ) mod m; c1, c2 正常的辅助函数, 后续探查位置加上一个依赖二次的方式的偏移量</p>
</li>
<li><p>双重探查: h(k,i) = (h1(k) + ih2(k)) mod m;</p>
<p>m为2的幂, 设计一个总能产生奇数的h2</p>
<p>m为素数, 设计一个总能返回较m小的正整数函数h2</p>
<p>2个m</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>   n.零零散散的知识点</p>
<ol>
<li><p>哈希表长是一个给定的长度(单个数据的最大长度?)</p>
</li>
<li><p>我们全部数据储存所需要的空间一定要小于哈希表长</p>
<ol start="3">
<li>Q: 字符串那个例子中左移的操作及其作用</li>
</ol>
</li>
</ol>
<h2 id="肆-排序算法"><a href="#肆-排序算法" class="headerlink" title="肆 排序算法"></a>肆 排序算法</h2><p>趁年少</p>
<ol start="0">
<li>基础<ol>
<li>排序稳定性: 序列中相同元素的相对位置在排列前后不变 </li>
</ol>
</li>
<li>插入排序: <ol>
<li>定义: 将无序子序列中的一个或几个记录插入到有序子序列中</li>
<li>步骤:<ol>
<li>在R[1…i-1]中找R[i]的位置</li>
<li>将R[j+1]到R[i-1]所有的元素后移一个位置</li>
<li>R[i]复制到R[j+1]上</li>
</ol>
</li>
<li>采用岗哨保存数据并比较</li>
<li>时间复杂度: O(n²)</li>
<li>空间复杂度: S(n) = O(1)</li>
<li>算法本质: <ol>
<li>比较和交换, 逆序的个数决定交换次数</li>
<li>改进: <ul>
<li>分组相隔较远的数据分到一组, 预先降低复杂度<img src="C:\Users\王冠骅\AppData\Roaming\Typora\typora-user-images\image-20201019200347142.png" alt="image-20201019200347142"></li>
</ul>
</li>
</ol>
</li>
<li>希尔排序<ol>
<li>思想: 分割成若干子文件, 对子文件分别进行插入排序, 文件有序时, 对整个文件进行一次直接插入排序</li>
<li>宏观调整: 跳跃式插入排序(即数据量比原来少, 虽然是O(n)的复杂度,但是时间也会降低)</li>
<li>增量序列</li>
</ol>
</li>
</ol>
</li>
<li>简单选择排序:<ol>
<li>选择序列中第i小的元素, 放入第i个位置.  直到遍历回末尾</li>
</ol>
</li>
<li>归并排序:<ol>
<li>思想: 将两个或两个以上的有序表组合成一个新的有序表</li>
<li>迭代算法: 把序列的每一个数据堪称长度为1的有序表, 将相邻两组进行合并得到长度为2的有序表(一次归并), 指导整个表归并成有序表</li>
</ol>
</li>
<li>快排<ol>
<li>思想</li>
<li>三者取中法: 取前,中,后三个位置的中间值, 把枢纽放在最后</li>
</ol>
</li>
<li>基数排序<ol>
<li>思想: 多关键字排序, 关键字序列有序, 最主关键字,最次关键字, 高位优先的多关键字排序, 低位优先</li>
<li></li>
</ol>
</li>
</ol>
<h2 id="伍"><a href="#伍" class="headerlink" title="伍"></a>伍</h2><ol>
<li><p>递归</p>
<ol>
<li>需求: 终止条件</li>
<li>尾递归可以使用循环求解</li>
</ol>
</li>
<li><p>分治</p>
<ol>
<li>问题特征: 缩小问题规模可容易解决, 可分解为若干个规模较小的相同问题, 具有最优子结构性质, 分解的子问题可合并为该问题的解, 分解的子问题是相互独立的</li>
<li>平衡子问题</li>
<li>时间复杂度: </li>
</ol>
</li>
<li><p>求解时间复杂度</p>
<ol>
<li><p>忽略细节: 取证</p>
</li>
<li><p>代换法:</p>
<ul>
<li>猜测解的形式, 通过数学归纳法求出常数</li>
<li> 归纳较小值时, 用所猜测的值去代替函数的解</li>
</ul>
</li>
<li><p>迭代法:</p>
<ul>
<li><p>直接展开的代数方法:</p>
<pre><code>展开成只有n和n的平方项</code></pre>
</li>
<li><p>递归树:</p>
<p>​    每个节点代表一个子问题的代价, 每一层代价相加得到一个每层代价的集合 </p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ol>
<li><p>二叉树的基本性质</p>
<ol>
<li><p>定义: 空树或根节点加左子树/右子树</p>
</li>
<li><p>基本形态: 空树, 根节点, 根左, 根右, 根左右</p>
</li>
<li><p><code>基本性质:</code> </p>
<ol>
<li><code>第i层至多有m^(i-1)个节点</code>    </li>
<li><code>深度为k的至多含(m^k - 1)/(m - 1)个节点</code></li>
<li><code>叶子节点n0, 度为2的节点n2, n0 = n2 + 1</code></li>
<li><code>具有n个节点的完全二叉树深度为log2n(下取整) + 1</code></li>
<li><code>节点数 = 所有节点度数+1</code> </li>
</ol>
</li>
<li><p>二叉树的存储</p>
<ol>
<li>补全为完全二叉树, 补全的单位只有位置而无数据</li>
<li>二叉链表:<ol>
<li>节点结构: Lchild, data, Rchild</li>
</ol>
</li>
<li>三叉链表:<ol>
<li>节点结构: parent, Lchild, data, Rchild</li>
</ol>
</li>
</ol>
</li>
<li><p>二叉树的遍历:</p>
<ol>
<li>递归遍历: <ul>
<li>先序</li>
<li>中序</li>
<li>后序</li>
<li>层次</li>
</ul>
</li>
</ol>
</li>
<li><p>层次遍历: </p>
<h2 id="树的应用"><a href="#树的应用" class="headerlink" title="树的应用"></a>树的应用</h2></li>
</ol>
</li>
<li><p>二叉搜索树</p>
<ol>
<li>定义: <ul>
<li>任意两个关键字不重复</li>
<li>右子树关键字大于根节点, 左子树关键字小于根节点</li>
<li>根节点的左右子树也是二叉搜索树</li>
<li><img src="C:\Users\王冠骅\AppData\Roaming\Typora\typora-user-images\image-20201224154815139.png" alt="image-20201224154815139" style="zoom:50%;" /></li>
</ul>
</li>
<li>操作:<ol>
<li>搜索: 比较左右子树, 小右大左</li>
<li>插入: 先搜索要插入元素位置, 若无元素, 则判断其与中断结点的大小, 插入, 并设置左右子树</li>
<li>删除:<ul>
<li>p是树叶: 直接删除</li>
<li>p有一个非空子树: 删除后将子树接上</li>
<li>p有两个非空子树: 将左子树最大或右子树最小的值替换到节点位置, 删除替换的值(我们选右子树最小, 因为其只有子树或有一个右子树的状态)</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>AVL树</p>
<ol>
<li><p>平衡树: 搜索树的高度总是Logn, 我们能保证查找, 插入和删除的时间为O(logn). 最坏情况下的高度为O(logn)的树称为平衡树.</p>
</li>
<li><p>简介: 左右子树是AVL且<code>左右子树高度差为1</code>, </p>
<img src="C:\Users\王冠骅\AppData\Roaming\Typora\typora-user-images\image-20201224211119329.png" alt="image-20201224211119329" style="zoom:50%;" />
</li>
<li><p>特性: 用旋转来保持平衡(旋转树根)</p>
</li>
<li><p>旋转操作:</p>
<ol>
<li><p>左旋: 右子树高于左子树 RR<img src="https://pic2.zhimg.com/v2-ecade466b0473b55dd6bea9a73df68e1_r.jpg" alt="preview"></p>
</li>
<li><p>右旋: 左子树高于右子树 LL</p>
<p><img src="https://pic4.zhimg.com/v2-75b99216e5bba6c6a0c1100525a9d0e7_r.jpg" alt="preview"></p>
</li>
<li><p>左右旋: LR或RL , 先将底下节点旋转为RR或RL, 再将整个节点旋转</p>
<p><img src="https://pic4.zhimg.com/80/v2-b380d3e99b7b3ee4508e129e66266aab_1440w.jpg" alt="img"></p>
</li>
<li><p>双旋转平衡是在单旋转的基础上加了判断</p>
<img src="C:\Users\王冠骅\AppData\Roaming\Typora\typora-user-images\image-20201224214329624.png" alt="image-20201224214329624" style="zoom: 50%;" />
</li>
<li><p>删除节点</p>
<p>在AVLTree类中增加删除节点方法，当删除完一个节点后，也进行调用<code>balance</code>方法，来维护平衡。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">private void remove(Node parentNode, Node node, int element) &#123;</span><br><span class="line">    if (node == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 先找到目标元素</span><br><span class="line">    int compareResult = node.compareTo(element);</span><br><span class="line">    if (compareResult &lt; 0) &#123;</span><br><span class="line">        remove(node, node.left, element);</span><br><span class="line">    &#125; else if (compareResult &gt; 0) &#123;</span><br><span class="line">        remove(node, node.right, element);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 找到目标元素，判断该节点是父节点的左子树还是右子树</span><br><span class="line">        boolean isLeftOfParent = false;</span><br><span class="line">        if (parentNode.left != null &amp;&amp; parentNode.left.compareTo(element) == 0) &#123;</span><br><span class="line">            isLeftOfParent = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 删除目标元素</span><br><span class="line">        if (node.left == null &amp;&amp; node.right == null) &#123; // （1）目标元素为叶子节点，直接删除</span><br><span class="line">            if (isLeftOfParent) &#123;</span><br><span class="line">                parentNode.left = null;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                parentNode.right = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (node.left != null &amp;&amp; node.right != null) &#123; // （2）目标元素即有左子树，也有右子树</span><br><span class="line">            // 找到右子树最小值（叶子节点），并将其删除</span><br><span class="line">            Node minNode = findMin(node.right);</span><br><span class="line">            remove(minNode.element);</span><br><span class="line">            // 将该最小值替换要删除的目标节点</span><br><span class="line">            minNode.left = node.left;</span><br><span class="line">            minNode.right = node.right;</span><br><span class="line">            if (isLeftOfParent) &#123;</span><br><span class="line">                parentNode.left = minNode;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                parentNode.right = minNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123; // （3）目标元素只有左子树，或只有右子树</span><br><span class="line">            if (isLeftOfParent) &#123;</span><br><span class="line">                parentNode.left = node.left != null ? node.left : node.right;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                parentNode.right = node.left != null ? node.left : node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    balance(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p><img src="C:\Users\王冠骅\AppData\Roaming\Typora\typora-user-images\image-20201204201220896.png" alt="image-20201204201220896"></p>
<ol>
<li><p>DJ算法</p>
<ol>
<li><p>松弛操作: 对于v, 我们想保存一个变量v.d, 用来记录从源节点s到节点v的最短路径权重的上界(int). v.d为s到v的最短路径估计. 其是唯一导致最短路径估计和前驱节点发生变化的操作</p>
<p>初始时将s到v之间的最短距离(d)设为正无穷, Π = NILL;</p>
<p>对边(u, v)松弛过程: 是否可对s到v的最短路径改善</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(v.d &gt; u.d + w(u,v))</span><br><span class="line">	v.d = u.d + w(u,v);</span><br><span class="line">	v.Π = u;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>稀疏图，数据结构中的一种定义图。与之相反的是稠密图。稀疏图的边数远远少于完全图，反之，稠密图的边数接近于或等于完全图。E和V^2的关系</p>
</li>
<li><p>性质:</p>
<ol>
<li>V个顶点的图最多有V(V+1) / 2 个边</li>
</ol>
</li>
</ol>
<h1 id="蚁群算法"><a href="#蚁群算法" class="headerlink" title="蚁群算法"></a>蚁群算法</h1><ol>
<li><p>简介: 群智能算法(一群无智能或轻微又智能的个体通过相互协作而表现出智能行为), 模仿蚂蚁觅食的过程来求得最优解, 启发式算法</p>
</li>
<li><p>原理: 蚁群中蚂蚁的数目为m, 城市之间的<strong>信息素</strong>用矩阵pheromone.</p>
<p>每只蚂蚁都有自己的内存, 内存中用一个**禁忌表(Tabu)**储存蚂蚁已访问的城市</p>
<p>还有一个**城市表(Allowed)**储存可访问的城市;</p>
<p>Delta储存其在一个循环中经过路径所释放的信息素</p>
</li>
</ol>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ol>
<li><p>简介: 多阶段过程转化为一系列单阶段问题, 利用各阶段的关系逐个求解</p>
<p>分解得到的子问题不是相互独立的, 子问题的数目只有多项式量级</p>
<p>保存子问题的答案, 需要时找出问题</p>
</li>
<li><p>要素:</p>
<ol>
<li>最优解结构: 自底向上构建</li>
<li>重叠子问题: 将子问题求解后保存在一个表格中, 用常数时间查看</li>
</ol>
</li>
<li><p>e.g: 带权重的任务安排问题:</p>
<ol>
<li><p>任务按最早结束时间升序排序</p>
</li>
<li><p>P(j) = 与j活动相容的最大的i 贪心一个大的</p>
<p><img src="C:\Users\王冠骅\AppData\Roaming\Typora\typora-user-images\image-20201214093207793.png" alt="image-20201214093207793"></p>
</li>
<li><p>OPT(j) = 前j个活动权重和最大值(1,2,3…j) 前j个活动我已经知道最大值了</p>
<p>目标: OPT(n) 一共n个任务, 即求出前n个任务的最大值</p>
<p>选择任务时有两种方法: 1. 不选择j 问题退化为OPT(j - 1), 即从(1,2,3…j)中找最优解  (有时候自己的权重小, 选上自己之后会耽误之前的最大值)</p>
<p>2, 选择活动j, 问题变为Wj + OPT(P(j)), 选择了活动j, 下一个活动是不能和 j 冲突的最大活动P(j)</p>
<p><img src="C:\Users\王冠骅\AppData\Roaming\Typora\typora-user-images\image-20201214093914092.png" alt="image-20201214093914092"></p>
</li>
<li><p>BinarySearch: 在current index之前找到一个相容的任务 (取最逼近的, 而非权重最高的)</p>
<p>compute[0]: P(j), compute[1]: OPT(j)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt; taskNum + <span class="number">1</span>; j++) &#123;</span><br><span class="line">	<span class="comment">//P(j)</span></span><br><span class="line">	compute[<span class="number">0</span>][j] = binarySereach(startArray[j], finishArray, j - <span class="number">1</span>);</span><br><span class="line">      </span><br><span class="line">	<span class="comment">//OPT(j)：OPT(j) ? Wj+OPT(P(j))</span></span><br><span class="line">	<span class="keyword">if</span> (compute[<span class="number">1</span>][j - <span class="number">1</span>] &gt; schedule[j<span class="number">-1</span>].iWight + compute[<span class="number">1</span>][compute[<span class="number">0</span>][j]])  					<span class="comment">//第一个任务信息在0号内存单元的，所以是schedule[j-1].iWight</span></span><br><span class="line">		compute[<span class="number">1</span>][j] = compute[<span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		compute[<span class="number">1</span>][j] = schedule[j<span class="number">-1</span>].iWight + compute[<span class="number">1</span>][compute[<span class="number">0</span>][j]];</span><br><span class="line">&#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure></li>
<li><p>总结:</p>
<ol>
<li>简介: 给定一组任务的开始与结束时间及任务的权重, 求在给定时间内权重最高的任务组</li>
<li>相容: 两任务时间不相交</li>
<li>贪心的问题</li>
<li>若是贪心(无记忆化)的话, 则问题需要(n3)</li>
<li>无法区分权重</li>
<li>分析问题:<ol>
<li>定义OPT(k): 任务k的最大权重, P(k): 与任务k相容性最好的任务(其结束时间与任务k开始时间最大)</li>
<li>将问题抽象, 任意一个任务i, 想让它生成的任务组权值最大, 我们有两种选法<ol>
<li>选择当前的任务Wi, 并选择与其相容性最好的任务OPT(P(i))</li>
<li>不选择当前任务, 而是采用OPT(i - 1)的序列 (因为我们是按结束时间升序排列, 有可能新任务的开始时间比max序列的结束时间长, 从而破坏了之前的序列);</li>
<li>构造状态转移方程</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><ol>
<li><p>简介:  堆是一个数组, 近似为一个完全二叉树, 除了最底层外, 该树是完全满的.</p>
<p>left(i) = 2i, right(i) = 2i + 1, parent(i) = 下取整(i/2)</p>
<p>最大堆: A[PARIENT(i)]&gt;=A[i]</p>
<p><img src="C:\Users\王冠骅\AppData\Roaming\Typora\typora-user-images\image-20201218154010424.png" alt="image-20201218154010424"></p>
</li>
<li><p>优先队列: </p>
<ol>
<li>用来维护一组元素构成的集合</li>
<li>操作: <ol>
<li>maxHeapify(): 保持最大堆的性质, 假定堆的其他子树都是最大堆, 从要调整的节点出发, 向下递归进行调整, 直到递归到自身就具有堆的性质的三个节点</li>
<li>increaseKey(): 从下往上调整, 遇到更大的值就交换</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><ol>
<li><p>简介: 一个小偷面前有一堆（n个）财宝，每个财宝有重量<code>w</code>和价值<code>v</code>两种属性，而他的背包只能携带一定重量的财宝（Capacity），在已知所有财宝的重量和价值的情况下，如何选取财宝，可以最大限度的利用当前的背包容量，取得最大价值的财宝（或求出能够获取财宝价值的最大值）。</p>
<h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><ol>
<li>每个物品拿与不拿</li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/09/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B/" data-id="ckjqkpugb0002e0va75mi5pxh" data-title="数据结构课程" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/01/01/hello-world/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Hello World
        
      </div>
    </a>
  
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/10/%E5%81%87%E6%9C%9F%E8%AE%A1%E5%88%92/">假期计划</a>
          </li>
        
          <li>
            <a href="/2021/01/07/%E9%92%A2%E7%AC%94,%20%E5%88%BA%E7%BB%A3%E6%89%8B%E5%B8%95%E5%92%8C%E6%96%AF%E8%BE%BE%E5%9F%BA%E8%A7%92%E7%9A%84%E5%8E%9F%E5%AD%90%E5%BC%B9/">钢笔,刺绣手帕和斯达基角的原子弹</a>
          </li>
        
          <li>
            <a href="/2021/01/01/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2020/09/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B/">数据结构课程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>